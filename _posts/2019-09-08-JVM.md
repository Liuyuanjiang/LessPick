---
layout: post
title:  JVM
date:   2019-09-08 023:08:00 +0800
categories: JVM
tag: 笔记
---	

* content
{:toc}

JVM 
====================================

垃圾收集器分类
------------------------------------

GC分类
------------------------------------

根据线程数分类
------------------------------------------------------------------------

	1. 串行垃圾回收器  
	串行回收指的是在同一时间段内只允许一件事情发生。 
	多个CUP可用时，也只能有一个CPU用于垃圾回收操作，并且在执行垃圾回收时，程序中的工作线程会被暂停，当垃圾收集工作完成后才会恢复之前被暂停的工作线程。
	 特点： 1. 仅仅使用单线程进行垃圾回收 2. 独占式的垃圾回收方式
	适用于 单CPU处理器较，较小应用内存的硬件平台 
	       	 
	

	2. 并行垃圾回收器
	并行收集器是工作在年轻代的垃圾收集器，知识简单的将串行收集器多线程化， 回收策略， 算法 以及参数和串行回收器一样 
	
	并行回收器页始独占式的回收器， 在收集过程中会 STW 。 由于并行回收使用多个线程回收，因此在并发能力比较强的CPU上， 它产生STW 会短于串行收集器 

根据工作模式分
------------------------------------------------------------------------
	1. 并发式垃圾回收器
	并发式垃圾回收器与应用程序相互交替工作， 尽可能减少STW	的时间，


	2. 独占式垃圾回收器
	独占式垃圾回收器一旦运行 就会STW ，停止所用应用程序，知道垃圾回收过程结束

按碎片处理方式分
------------------------------------------------------------------------
	1. 压缩式垃圾回收器
	2. 非压缩式垃圾回收器

工作的内存区间分
------------------------------------------------------------------------
	1. 年轻代垃圾回收期
	2. 老年代垃圾回收期
	 
常见垃圾收集器
------------------------------------------------------------------------

1. Serial/Serial Old 收集器：

		Serial 收集器作用于年轻代中， 采用 复制算法 ， 属于串行回收方式
		Serial Old 收集器 采用串行回收， STW机制， 采用 标记-压缩 算法 ，
		"-XX:+UseSerialGC" 手动指定Serial收集器执行内存回收任务
		"-XX:+PrintGCDetails" 年轻代串行收集器的工作日志开关

2. ParNew 收集器

		ParnNew 可以说是Serial收集器的多线程版本，
		ParNew 收集器在 年轻代 中同样才用的也是复制算法 和 STW 机制  并行回收机制
		ParnNew 收集器的优势体现在多CPU，多核心的环境中，   在某些注重低延迟的应用场景下ParNew 和 CMS 收集器的组合模式， 在Server 模式下的内存回收效果很好， 和使用 "-XX:+UserParNewGC" 手动指定使用ParNew收集器
		"-XX:+UserParallelGC" 表示 年轻代使用并行垃圾回收器， 老年代使用串行收集器 
		
3. Parallel/Parallel Old 收集器

		Parallel收集器 并行回收 复制算法 年轻代 STW ， 和ParNew不同Parrllel收集器可以控制程序的吞吐量大小 ， 
		被称为-吞吐量有限的垃圾收集器， 
		"-XX:+GCTimeRatio:N" 设置执行内存回收的时间所占JVM运行总时间的比例， 1/(1+N) 默认N为99
		"-XX:+MaxGCPauseMills" 设置执行内存回收是STW 的暂停时间阈值， 若指定该值，则尽可能地在设定的时间内完成内存回收。
		"-XX:+UseAdaptiveSizePolicy" 选项用于设置GC的自动分代大小调节策略。
		
		Parallel Old 收集器采用了 标记-压缩算法 ， 用于老年代垃圾回收 ， 并行回收 STW 
		parallel 和 Parallel Old 收集器的组合 在Server 模式下的内存回收性能不错，

		"-XX:UseParallelOldGC"可在年轻代和老年代都是用并行回收收集器， 此收集器重点关注吞吐量
		"-XX:ParallelGCThreads" 可用于设置垃圾回收时的线程数量
	
4. CMS(Concurrent-Mark-Sweep) 收集器

		基于低延迟的考虑  ， 并行垃圾回收器， 老年代垃圾收集， 低延迟， 采用标记清除算法。会有短暂的STW
		步骤 ：
		1. 初始标记(Initial Mark) ： STW 标记根对象直接关联、可达的对象 
		2. 并发标记(Concurrent Mark) ：将不可达对象 标记为垃圾对象
		3. 再次标记(Remark) ： STW 确保垃圾对象被成功且正确得标记 
		4. 并发清除(Concurrent Sweep)： 垃圾回收

		"-XX:+UseCMS-CompactAtFullCollection" 用于指定在执行完FullGC 之后 是否对内存空间进行压缩整理，
		"-XX:+CMSFullGCs-BeforeCompaction" 设定在执行多少次FullGC 之后对内存空间进行压缩整理
		"-XX:+CMSInitiatingOccupanyFraction" 设置老年代中的内存使用率达到多少百分比的时候执行内存回收 JDK1.6之前默认值为68% JDK1.6 之后默认92% 
		
		CMS垃圾收集器在回收过程中程依然可能会产生垃圾，所以需要设定一个阈值来进行垃圾回收，如果CMS回收失败，JVM则会启动老年代串行收集器进行垃圾回收，程序的STW时间会较长， 所以可以在内存增长缓慢的程序里面设置较大阈值，在内存增长快速的程序里面设置较小的阈值， 避免触发老年代串行收集器。

		"-XX:UseConMarkSweepGC" 表示年轻代使用并行收集器，老年代使用CMS

		年轻代  并行收集器工作时的线程数量可以使用 "-XX:ParallelGCThreads" 选项指定，  一般最好与CPU的数量相当
		
	
	5. G1(Garbage-First) 收集器

	
